#include <stdio.h>
#include <stdlib.h>

#include "readAdjacency.h"
#include "linkedList.h"
#include "stack.h"
#include "minHeap.h"

#define DEFAULT_PRIORITY_VALUE 100000

int nodeCount=0;

void insertElement(int keyId, int priority, HEAP priorityQueueRoot,int* locationVector)
{
	HEAP tempNode;
	tempNode=getHeapNode();
	tempNode->priority=priority;
	tempNode->keyId=keyId;
	tempNode->leftChild=NULL;
	tempNode->rightChild=NULL;
	tempNode->parent=NULL;
	nodeCount++;
	addElementToHeap(priorityQueueRoot,tempNode,nodeCount,locationVector);
	return;
}

HEAP createPriorityQueue(LINKED_LIST* vertex,int count,int* locationVector)
{
	if(count<=0)
		exit(-1);

	HEAP priorityQueueRoot;
	priorityQueueRoot=getHeapNode();
	priorityQueueRoot->keyId=-1;
	priorityQueueRoot->priority=DEFAULT_PRIORITY_VALUE;
	priorityQueueRoot->rightChild=NULL;
	priorityQueueRoot->leftChild=NULL;
	priorityQueueRoot->rightChild=NULL;


	int k;

	for(k=0;k<count;k++) 
	{
		locationVector[k]=k+1;
		insertElement(k+1,DEFAULT_PRIORITY_VALUE,priorityQueueRoot,locationVector);
	}

	return priorityQueueRoot;
}

void changePriority(int position,int newPriority, int* locationVector,HEAP rootElement, int* prevNode, int deletedKeyWeight,int toBeDeletedKey)
{
	int poppedNumber,pushNumber; 
	STACK myStackHead; //Stack used to find where to move to trace the element
	myStackHead=(STACK)malloc(sizeof(struct stack));
	myStackHead->top=getNode();
	myStackHead->top->next=NULL;

	HEAP tempNode;
	tempNode=getHeapNode();
	tempNode=rootElement;
	int altPriority;
	
	int temp=position;
	while(temp!=0) //Get binary form of count
	{
		pushNumber=temp%2; //Remainder is pused on stack
		temp/=2;
		push(myStackHead,pushNumber);

	}

	poppedNumber=pop(myStackHead); //last number represents the root element so popped out
	if(poppedNumber==-1)
		return;
	while(1)
	{
		poppedNumber=pop(myStackHead); //pop the number on stack
		if(poppedNumber==-1) //If location reached
		{


			if(tempNode->priority==DEFAULT_PRIORITY_VALUE)
			{

				tempNode->priority=newPriority;
				prevNode[(tempNode->keyId)-1]=toBeDeletedKey;
				heapifyUp(tempNode,locationVector);
			}
			else
			{
				altPriority=newPriority;
				if((tempNode->priority)>altPriority)
				{
					prevNode[(tempNode->keyId)-1]=toBeDeletedKey;
					tempNode->priority=altPriority;
				}
				heapifyDown(tempNode,locationVector);
			}
			break;
		}			
		else if(poppedNumber==0) //If popped number is 0 then move left
		{
			tempNode=tempNode->leftChild;
			temp=poppedNumber;
		}
		else if(poppedNumber==1) //If popped number is 1 then move right
		{
			tempNode=tempNode->rightChild;
			temp=poppedNumber;
		}
	}
	return;

}


void prims(LINKED_LIST *vertex, HEAP priorityQueueRoot,int *locationVector,int *prevNode,int startingNode,int* weightArray,int *outputArray, int i)
{
	
	int tempKey,position;
	int tempWeightage;
	int toBeDeletedKey,deletedKeyWeight;


	inOrderTraversal(priorityQueueRoot);
	if(nodeCount==0) //If queue is empty then nothing can be deleted further
	{
		return;
	}
	else if(nodeCount==1) //If there is any element in heap tree
	{
		toBeDeletedKey=priorityQueueRoot->keyId;
		deletedKeyWeight=priorityQueueRoot->priority;
		outputArray[i]=toBeDeletedKey;
		weightArray[i]=deletedKeyWeight;
		i++;
		nodeCount--; //Decrease the node count
		priorityQueueRoot->keyId=DEFAULT_PRIORITY_VALUE;
		priorityQueueRoot->rightChild=NULL;
		priorityQueueRoot->leftChild=NULL;
		priorityQueueRoot->rightChild=NULL;
		return;
	}
	else
	{
		
		toBeDeletedKey=priorityQueueRoot->keyId;
		deletedKeyWeight=priorityQueueRoot->priority;
		outputArray[i]=toBeDeletedKey;
		weightArray[i]=deletedKeyWeight;
		i++;
		LINKED_LIST tempNode=vertex[toBeDeletedKey-1]->next;
		deleteElementFromHeap (priorityQueueRoot, nodeCount,locationVector); //delete the element
		nodeCount--;

		locationVector[toBeDeletedKey-1]=0;

		while(tempNode!=NULL)
		{

			tempKey=tempNode->key;
			tempWeightage=tempNode->weight;
			
			position=locationVector[tempKey-1];
			changePriority(position,tempWeightage,locationVector,priorityQueueRoot,prevNode,deletedKeyWeight,toBeDeletedKey);


			tempNode=tempNode->next;
		}
		

	}

	 //Decrease the node count
	prims(vertex,priorityQueueRoot,locationVector,prevNode,1,weightArray,outputArray,i);


	return;

}

int main(int argc, char *argv[])
{
	if ( argc != 2 ) //argc should be 2 for correct execution
	{
       		printf( "usage: %s filename", argv[0] );//argc[0] will be the executable name
		exit(-1);
	}
	system("clear");

	LINKED_LIST *vertex; //To store the adjacency list
	vertex=NULL;
	int i,startingNode;
	int count=getNodeCount(argv[1]); //Count the number of nodes in adjacency list
	vertex=(LINKED_LIST*)readAdjacencyList(argv[1],vertex,count); //Read the adjacency list from file
	printAdjacencyList(vertex,count); //Prints the adjacency list

	int *locationVector=(int*)malloc(sizeof(int)*count);
	int *prevNode=(int*)malloc(sizeof(int)*count);
	int *weightArray=(int*)malloc(sizeof(int)*count);
	int *outputArray=(int*)malloc(sizeof(int)*count);
	for(i=0;i<count;i++)
	{
		locationVector[i]=0;
		prevNode[i]=-1;
		weightArray[i]=-1;
		outputArray[i]=-1;
	}

	HEAP priorityQueueRoot;
	priorityQueueRoot=createPriorityQueue(vertex,count,locationVector);

	//inOrderTraversal(priorityQueueRoot);

	printf("\nEnter the starting node : ");
	scanf("%d",&startingNode);

		prevNode[startingNode-1]=startingNode;
		changePriority(startingNode,0,locationVector,priorityQueueRoot,prevNode,0,startingNode);

	prims(vertex, priorityQueueRoot,locationVector,prevNode,startingNode,weightArray,outputArray,0);

	printf("\n\nMinimum Spanning tree from node %d:\n",startingNode);
	int sum=0;
	for(i=0;i<count;i++)
	{
		printf("%d->",outputArray[i]);
		sum+=weightArray[i];
	}
	printf("\n\nTotal Weight %d:\n",sum);

	return 0;
}
