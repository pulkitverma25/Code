#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "readAdjacency.h"
#include "linkedList.h"
#include "stack.h"
#include "minHeap.h"

#define DEFAULT_PRIORITY_VALUE 100000
//#define kValue 2

int nodeCount=0;

struct graphedge
{
	int startVertex;
	int endVertex;
	int weight;
};
typedef struct graphedge* EDGE;

void insertElement(int keyId, int priority, HEAP priorityQueueRoot,int* locationVector)
{
	HEAP tempNode;
	tempNode=getHeapNode();
	tempNode->priority=priority;
	tempNode->keyId=keyId;
	tempNode->leftChild=NULL;
	tempNode->rightChild=NULL;
	tempNode->parent=NULL;
	nodeCount++;
	addElementToHeap(priorityQueueRoot,tempNode,nodeCount,locationVector);
	return;
}

HEAP createPriorityQueue(LINKED_LIST* vertex,int count,int* locationVector)
{
	if(count<=0)
		exit(-1);

	HEAP priorityQueueRoot;
	priorityQueueRoot=getHeapNode();
	priorityQueueRoot->keyId=-1;
	priorityQueueRoot->priority=DEFAULT_PRIORITY_VALUE;
	priorityQueueRoot->rightChild=NULL;
	priorityQueueRoot->leftChild=NULL;
	priorityQueueRoot->rightChild=NULL;


	int k;

	for(k=0;k<count;k++) 
	{
		locationVector[k]=k+1;
		insertElement(k+1,DEFAULT_PRIORITY_VALUE,priorityQueueRoot,locationVector);
	}

	return priorityQueueRoot;
}

void changeDijkastraPriority(int position,int newPriority, int* locationVector,HEAP rootElement, int* prevNode, int deletedKeyWeight,int toBeDeletedKey)
{
	int poppedNumber,pushNumber; 
	STACK myStackHead; //Stack used to find where to move to trace the element
	myStackHead=(STACK)malloc(sizeof(struct stack));
	myStackHead->top=getNode();
	myStackHead->top->next=NULL;

	HEAP tempNode;
	tempNode=getHeapNode();
	tempNode=rootElement;
	int altPriority;
	
	int temp=position;
	while(temp!=0) //Get binary form of count
	{
		pushNumber=temp%2; //Remainder is pused on stack
		temp/=2;
		push(myStackHead,pushNumber);

	}

	poppedNumber=pop(myStackHead); //last number represents the root element so popped out
	if(poppedNumber==-1)
		return;
	while(1)
	{
		poppedNumber=pop(myStackHead); //pop the number on stack
		if(poppedNumber==-1) //If location reached
		{


			if(tempNode->priority==DEFAULT_PRIORITY_VALUE)
			{

				tempNode->priority=newPriority+deletedKeyWeight;
				prevNode[(tempNode->keyId)-1]=toBeDeletedKey;
				heapifyUp(tempNode,locationVector);
			}
			else
			{
				altPriority=newPriority+deletedKeyWeight;
				if((tempNode->priority)>altPriority)
				{
					prevNode[(tempNode->keyId)-1]=toBeDeletedKey;
					tempNode->priority=altPriority;
				}
				heapifyDown(tempNode,locationVector);
			}
			break;
		}			
		else if(poppedNumber==0) //If popped number is 0 then move left
		{
			tempNode=tempNode->leftChild;
			temp=poppedNumber;
		}
		else if(poppedNumber==1) //If popped number is 1 then move right
		{
			tempNode=tempNode->rightChild;
			temp=poppedNumber;
		}
	}
	free(myStackHead);
	return;

}


void dijkastra(LINKED_LIST *vertex, HEAP priorityQueueRoot,int *locationVector,int *prevNode,int startingNode,int* weightArray)
{
	
	int tempKey,position;
	int tempWeightage;
	int toBeDeletedKey,deletedKeyWeight;



	inOrderTraversal(priorityQueueRoot);
	if(nodeCount==0) //If queue is empty then nothing can be deleted further
	{
		return;
	}
	else if(nodeCount==1) //If there is any element in heap tree
	{
		toBeDeletedKey=priorityQueueRoot->keyId;
		deletedKeyWeight=priorityQueueRoot->priority;
		weightArray[toBeDeletedKey-1]=deletedKeyWeight;
		nodeCount--; //Decrease the node count
		priorityQueueRoot->keyId=DEFAULT_PRIORITY_VALUE;
		priorityQueueRoot->rightChild=NULL;
		priorityQueueRoot->leftChild=NULL;
		priorityQueueRoot->rightChild=NULL;
		return;
	}
	else
	{

		toBeDeletedKey=priorityQueueRoot->keyId;
		deletedKeyWeight=priorityQueueRoot->priority;
		weightArray[toBeDeletedKey-1]=deletedKeyWeight;
		LINKED_LIST tempNode=vertex[toBeDeletedKey-1]->next;
		deleteElementFromHeap (priorityQueueRoot, nodeCount,locationVector); //delete the element
		nodeCount--;

		locationVector[toBeDeletedKey-1]=0;

		while(tempNode!=NULL)
		{

			tempKey=tempNode->key;
			tempWeightage=tempNode->weight;
			

			
			position=locationVector[tempKey-1];
			changeDijkastraPriority(position,tempWeightage,locationVector,priorityQueueRoot,prevNode,deletedKeyWeight,toBeDeletedKey);


			tempNode=tempNode->next;
		}
		

	}

	 //Decrease the node count
	dijkastra(vertex,priorityQueueRoot,locationVector,prevNode,1,weightArray);


	return;

}

int* func(int count, int startingNode,char* fileName)
{
	LINKED_LIST *vertex; //To store the adjacency list
	vertex=NULL;
	int i;
	//Count the number of nodes in adjacency list
	vertex=(LINKED_LIST*)readAdjacencyList(fileName,vertex,count); //Read the adjacency list from file
	
	if(startingNode==1)
	{
		printf("\nAdjacency List of Graph G:\n");	
		printAdjacencyList(vertex,count); //Prints the adjacency list
	}

	int *locationVector=(int*)malloc(sizeof(int)*count);
	int *prevNode=(int*)malloc(sizeof(int)*count);
	int *weightArray=(int*)malloc(sizeof(int)*count);
	for(i=0;i<count;i++)
	{
		locationVector[i]=0;
		prevNode[i]=-1;
		weightArray[i]=-1;
	}

	HEAP priorityQueueRoot;
	priorityQueueRoot=createPriorityQueue(vertex,count,locationVector);

	prevNode[startingNode-1]=startingNode;
	changeDijkastraPriority(startingNode,0,locationVector,priorityQueueRoot,prevNode,0,startingNode);

	dijkastra(vertex, priorityQueueRoot,locationVector,prevNode,startingNode,weightArray);
	/*
	printf("\n\nShortest Paths from Node %d to:\n",startingNode);
	for(i=0;i<count;i++)
	{
		temp=0;
		prev=prevNode[i];
		//printf("Inside temp, prev=%d",prev);
		printf("\nNode %d| Weight= %d | Path= %d",i+1,weightArray[i],i+1);
		while(prev!=startingNode)
		{
			//printf("Inside temp");
			temp=prevNode[prev-1];
			printf("->%d",prev);
			prev=temp;
			//temp=0;
		}
		printf("->%d",startingNode);
	}
	printf("\n\n");
	*/
	return weightArray;
}

void insertsort (EDGE* x, int n)
{
	int i,k,y;
	EDGE temp;
	temp=(EDGE)malloc(sizeof(struct graphedge));
	for (k=1; k<n; k++)
	{
		y=x[k]->weight;
		temp->startVertex=x[k]->startVertex;
		temp->endVertex=x[k]->endVertex;
		temp->weight=x[k]->weight;
		for (i=k-1; i>=0 && y<x[i]->weight; i--)
		{
			x[i+1]->startVertex=x[i]->startVertex;
			x[i+1]->endVertex=x[i]->endVertex;
			x[i+1]->weight=x[i]->weight;
			
		}
		x[i+1]->startVertex=temp->startVertex;
		x[i+1]->endVertex=temp->endVertex;
		x[i+1]->weight=temp->weight;
	}

	printf("\n");
	free(temp);
}

int main(int argc, char *argv[])
{
	if ( argc != 2 ) //argc should be 2 for correct execution
	{
       		printf( "usage: %s filename\n\n", argv[0] );//argc[0] will be the executable name
		exit(-1);
	}
	system("clear");

	int kValue;
	printf("\n\nEnter value of k: ");
	scanf("%d",&kValue);

	char fileName[30];
	int i,j;
	strcpy(fileName,argv[1]);

	int count=getNodeCount(fileName); 

	//******Minimum Weight for all (u,v)*****
	int** minWeightArray=(int**)malloc(sizeof(int*)*count);
	for(i=0;i<count;i++)
		minWeightArray[i]=(int*)malloc(sizeof(int)*count);

	for(i=0;i<count;i++)
		minWeightArray[i]=func(count, i+1,fileName);

	printf("All Source Shortest Path Matrix:\n");
	for(i=0;i<count;i++)
	{
		for(j=0;j<count;j++)		
			printf("%d\t",minWeightArray[i][j]);
		printf("\n");	
	}	
	//printf("\n");

	//****************************************

	LINKED_LIST *vertex2; //To store the adjacency list
	vertex2=NULL;

	vertex2=(LINKED_LIST*)readAdjacencyList(fileName,vertex2,count);

	int maxEdgeCount=count*count;
	EDGE* edgeArray=(EDGE*)malloc(sizeof(EDGE*)*maxEdgeCount*maxEdgeCount);


	int k=0,z,skip=0;
	//printAdjacencyList(vertex2,count);
	for(i=0;i<count;i++)
	{
		LINKED_LIST tempNode=getNode();
		tempNode=vertex2[i]->next;	
		while(tempNode != NULL)
		{
			skip=0;
			
			for(z=0;z<=k-1;z++)
			{
				if(edgeArray[z]->startVertex==tempNode->key && edgeArray[z]->endVertex==i+1)
				{
					skip=1;
					break;
				}
			}
		
			if(skip==0)
			{
			edgeArray[k]=(EDGE)malloc(sizeof(struct graphedge));
			edgeArray[k]->startVertex=i+1;
			edgeArray[k]->endVertex=tempNode->key;
			edgeArray[k]->weight=tempNode->weight;
			k++;
			//printf("->(%d,%d)",tempNode->key,tempNode->weight);
			}

			
			tempNode=tempNode->next;
		}
		
	}


	insertsort(edgeArray,k);	

	printf("Sorted Array of edges:\n");
	for(i=0;i<k;i++)
	{
		
		printf("start=%d\tend=%d\tweight=%d\n",edgeArray[i]->startVertex,edgeArray[i]->endVertex,edgeArray[i]->weight);

	}


	//STEP3
	LINKED_LIST *vertex3;
	vertex3=(LINKED_LIST*)malloc(count*sizeof(LINKED_LIST)); //Allocates the memory to pointer array storing the adjacency list
	LINKED_LIST *lastNodeArray;
	lastNodeArray=(LINKED_LIST*)malloc(count*sizeof(LINKED_LIST));


	for(z=0;z<count;z++) //Allocates memory to each list corresponding to a single vertex
	{
		vertex3[z]=getNode();
		vertex3[z]->next=NULL;
	}
	for(z=0;z<count;z++)
	{
	lastNodeArray[z]=vertex3[z];
	}
	

	int** adjacencyMatrixH=(int**)malloc(sizeof(int*)*count);
	for(i=0;i<count;i++)
		adjacencyMatrixH[i]=(int*)malloc(sizeof(int)*count);
	
	for(i=0;i<count;i++)
		for(j=0;j<count;j++)
			adjacencyMatrixH[i][j]=0;

	int node1,node2;
	for(i=0;i<k;i++)
	{
		//printf("weight=%d\n",edgeArray[i]->weight);
		node1=edgeArray[i]->startVertex;
		node2=edgeArray[i]->endVertex;
		LINKED_LIST *vertex4;
		vertex4=(LINKED_LIST*)malloc(count*sizeof(LINKED_LIST)); 
		int *locationVector=(int*)malloc(sizeof(int)*count);
		int *prevNode=(int*)malloc(sizeof(int)*count);
		int *weightArray=(int*)malloc(sizeof(int)*count);
		for(z=0;z<count;z++)
		{
			locationVector[z]=0;
			prevNode[z]=-1;
			weightArray[z]=-1;
		}

		HEAP priorityQueueRoot;
		priorityQueueRoot=createPriorityQueue(vertex3,count,locationVector);



		int startingNode=node1;
		prevNode[node1-1]=node1;
		changeDijkastraPriority(startingNode,0,locationVector,priorityQueueRoot,prevNode,0,startingNode);

			dijkastra(vertex3, priorityQueueRoot,locationVector,prevNode,startingNode,weightArray);
		//for(z=0;z<count;z++)
			//printf("weightArray[%d]=%d\n",z,weightArray[z]);
		if(weightArray[node2-1]>=100000)
		{
			adjacencyMatrixH[node1-1][node2-1]=1;
			LINKED_LIST tempNode; //Create a new node when space encountered
			tempNode=getNode();
			tempNode->key=edgeArray[i]->endVertex;
			tempNode->weight=edgeArray[i]->weight;
			tempNode->next=NULL;
			lastNodeArray[node1-1]->next=tempNode;
			lastNodeArray[node1-1]=tempNode;
		
			LINKED_LIST tempNode2; //Create a new node when space encountered
			tempNode2=getNode();
			tempNode2->key=edgeArray[i]->startVertex;
			tempNode2->weight=edgeArray[i]->weight;
			tempNode2->next=NULL;
			lastNodeArray[node2-1]->next=tempNode2;
			lastNodeArray[node2-1]=tempNode2;
		
		}

		//else if(kValue*edgeArray[i]->weight<weightArray[node2-1])
		else if(kValue*minWeightArray[node1-1][node2-1]>edgeArray[i]->weight)	
		{
			//printf("start=%d\tend=%d\tweight=%d\n\n",edgeArray[i]->startVertex,edgeArray[i]->endVertex,edgeArray[i]->weight);
			adjacencyMatrixH[node1-1][node2-1]=1;
			LINKED_LIST tempNode; //Create a new node when space encountered
			tempNode=getNode();
			tempNode->key=edgeArray[i]->endVertex;
			tempNode->weight=edgeArray[i]->weight;
			tempNode->next=NULL;
			lastNodeArray[node1-1]->next=tempNode;
			lastNodeArray[node1-1]=tempNode;
		
			LINKED_LIST tempNode2; //Create a new node when space encountered
			tempNode2=getNode();
			tempNode2->key=edgeArray[i]->startVertex;
			tempNode2->weight=edgeArray[i]->weight;
			tempNode2->next=NULL;
			lastNodeArray[node2-1]->next=tempNode2;
			lastNodeArray[node2-1]=tempNode2;
		}
		free(vertex4);
		free(locationVector);
		free(prevNode);
		free(weightArray);
		free(priorityQueueRoot);	
	}

	/*printf("\n\nAdjacency Matrix of Graph H\n");
	for(i=0;i<count;i++)
	{
		for(j=0;j<count;j++)
			printf("%d\t",adjacencyMatrixH[i][j]);
	printf("\n");
	
	}*/
	printf("\nAdjacency List of Graph H:\n");
	printAdjacencyList(vertex3, count);
	return 0;
}
